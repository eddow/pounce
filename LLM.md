# Pounce LLM Cheat Sheet

## Coding Standards
1. **Imports**: Do NOT include file extensions (like `.ts`, `.tsx`) in import paths.
   - Correct: `import { foo } from './bar'`
   - Incorrect: `import { foo } from './bar.ts'`
2. If what you care of depends on the environment (node/dom), read the [Dual entry-point policy](./dual-ep-policy.md).
3. **JSX Types**: Global JSX types (`h`, `Fragment`, `JSX.IntrinsicElements`) come from `@pounce/core/dist/types/jsx.d.ts`, linked via `/// <reference>` in `dist/index.d.ts`.
   - Ensure `@pounce/core` is built (`pnpm -C packages/core build`)
   - Check `tsconfig.json` paths point to `dist/` not `dist/src/`
   - Test directories need their own `tsconfig.json` extending the main one (they're excluded by default)
   - See `packages/plugin/sandbox/application.md` for detailed investigation
   - **DTS gotcha**: Packages with `dom`/`node` entry points (no `index`) won't generate `dist/index.d.ts` automatically. Core uses an `afterBuild` hook in its vite config to create it. If `package.json` exports or downstream `tsconfig.json` paths reference `dist/index.d.ts`, it must exist.
4. **mutts types**: `dist/index.d.ts` is generated by a `closeBundle` plugin in `rollup.config.js` (not by `rollup-plugin-dts` directly, which drops named re-exports). It re-exports from `./src/index` (the intermediate files). All pounce tsconfig `paths` should point to `../../../mutts/dist/index.d.ts`.
5. Project state: The project is not even alpha, the only consumers are the test: Backward compatibility is *never* an issue

## Library Import Standardization
**CRITICAL**: All packages MUST import from other packages' built `dist/` directories, NEVER from source directories.

### Rule
- **Always import from `dist/`**: When one package imports from another, use the built distribution files.
- **NEVER import from `src/`**: Source imports break builds and cause TypeScript errors.
  - Exception: A package, its tests, and its examples *do* import from its own `src/` directory (e.g., `@pounce/core` importing from its own `src/`), but NEVER from another package's `src/`.

### Examples
```json
// tsconfig.json - CORRECT
"paths": {
  "@pounce/core": ["./core/src"],  // Only for core itself!
  "mutts": ["../../../mutts/src"] // Only for mutts itself!
}

// tsconfig.json - WRONG for downstream packages
"paths": {
  "@pounce/core": ["../../../core/src"], // WRONG!
  "mutts": ["../../../mutts/src"]       // WRONG!
}

// tsconfig.json - CORRECT for downstream packages
"paths": {
  "@pounce/core": ["../../../core/dist"], // CORRECT!
  "mutts": ["../../../mutts/dist"]       // CORRECT!
}
```

### Why This Rule Exists
1. **Build Consistency**: The build process uses compiled files, not source files.
2. **Type Safety**: Built `.d.ts` files contain the actual exported types.
3. **Circular Dependencies**: Source imports can create circular dependency issues.
4. **Clean Builds**: Prevents TypeScript errors from leaking between packages.

### Exception
A package may import from its own `src/` directory (e.g., `@pounce/core` importing from its own `src/`), but NEVER from another package's `src/`.

## Component Body Rules
1. **Never read `props.xxx` bare in the component body** — it destroys reactivity. The component body runs once; the captured value never updates. Use one of:
   - **JSX inline**: `class={props.variant ?? 'default'}` — babel wraps in `r()`, so the read is deferred.
   - **`defaults()` proxy**: `const p = defaults(props, { gap: 'md' })` — zero-cost proxy, `p.gap` is `props.gap ?? 'md'` with `undefined` stripped from the type. Use `p.xxx` for defaulted keys, `props.xxx` for the rest.
   - **Getter object**: `const state = { get variant() { return props.variant } }` — deferred until evaluated.
   - **Callback/effect**: reads inside `effect()`, `attend()`, event handlers, or `<for each>` callbacks are fine.
2. **Adapter architecture**: `@pounce/ui` is headless (models + types only). Import components from the adapter: `import { Button } from '@pounce/adapter-pico'`. No `setAdapter`, no `FrameworkAdapter`, no registry. `DisplayProvider` is DOM-only — import from `@pounce/kit/dom`.

## Babel Plugin Binding Rules
1. **Two-way** (`r(getter, setter)`): member expressions (`state.name`, `props.count`) and mutable bare identifiers (`let`/`var`).
2. **One-way** (`r(() => expr)`): complex expressions (calls, template literals, binary ops with non-safe operands).
3. **No wrapping**: `const` variables, imports, function declarations, parameters, literals, arrow functions, safe objects/arrays — `isSafeExpression` returns `true`.
4. The check uses Babel's `path.scope.getBinding(name).kind` to distinguish `let`/`var` from `const`/`module`/`param`/`hoisted`.

## Renderer Gotchas
1. **Event handler props get bidi `ReactiveProp` from babel**: `props.onClick` is a member expression → babel wraps as `r(() => props.onClick, val => props.onClick = val)` with a setter. `attachAttribute` in `renderer-internal.ts` must guard `on[A-Z]` keys from the bidi path, otherwise the handler is silently swallowed by `setHtmlProperty`. Guard: `value.set && !/^on[A-Z]/.test(key)`.

## Reconciler Gotchas
1. **Don't double-wrap in `processChildren`**: `renderChild` must return `renderer.render(scope)` array results directly — NOT wrapped in another `processChildren()`. `render()` already returns a `processChildren` result for components/fragments. Double-wrapping stores a reactive array inside a reactive array. When the inner one is replaced, mutts' `recursiveTouching` (same prototype → recursive diff path) swallows the identity-change notification, so the outer `flattenNodes` lift is never notified and `reconcile` never updates the DOM.