# Pounce LLM Cheat Sheet

## Coding Standards
1. **Imports**: Do NOT include file extensions (like `.ts`, `.tsx`) in import paths.
   - Correct: `import { foo } from './bar'`
   - Incorrect: `import { foo } from './bar.ts'`
2. If what you care of depends on the environment (node/dom), read the [Dual entry-point policy](./dual-ep-policy.md).
3. **JSX Types**: Global JSX types (`h`, `Fragment`, `JSX.IntrinsicElements`) come from `@pounce/core/dist/types/jsx.d.ts`, linked via `/// <reference>` in `dist/index.d.ts`.
   - Ensure `@pounce/core` is built (`pnpm -C packages/core build`)
   - Check `tsconfig.json` paths point to `dist/` not `dist/src/`
   - Test directories need their own `tsconfig.json` extending the main one (they're excluded by default)
   - See `packages/plugin/sandbox/application.md` for detailed investigation
   - **DTS gotcha**: Packages with `dom`/`node` entry points (no `index`) won't generate `dist/index.d.ts` automatically. Core uses an `afterBuild` hook in its vite config to create it. If `package.json` exports or downstream `tsconfig.json` paths reference `dist/index.d.ts`, it must exist.
4. **mutts types**: `dist/index.d.ts` is generated by a `closeBundle` plugin in `rollup.config.js` (not by `rollup-plugin-dts` directly, which drops named re-exports). It re-exports from `./src/index` (the intermediate files). All pounce tsconfig `paths` should point to `../../../mutts/dist/index.d.ts`.
5. Project state: The project is not even alpha, the only consumers are the test: Backward compatibility is *never* an issue

## Component Body Rules
1. **Never read `props.xxx` bare in the component body** — it destroys reactivity. The component body runs once; the captured value never updates. Use one of:
   - **JSX inline**: `class={props.variant ?? 'default'}` — babel wraps in `r()`, so the read is deferred.
   - **`defaults()` proxy**: `const p = defaults(props, { gap: 'md' })` — zero-cost proxy, `p.gap` is `props.gap ?? 'md'` with `undefined` stripped from the type. Use `p.xxx` for defaulted keys, `props.xxx` for the rest.
   - **Getter object**: `const state = { get variant() { return props.variant } }` — deferred until evaluated.
   - **Callback/effect**: reads inside `effect()`, `attend()`, event handlers, or `<for each>` callbacks are fine.
2. **Adapter architecture**: `@pounce/ui` is headless (models + types only). Import components from the adapter: `import { Button } from '@pounce/adapter-pico'`. No `setAdapter`, no `FrameworkAdapter`, no registry. `DisplayProvider` is DOM-only — import from `@pounce/kit/dom`.

## Babel Plugin Binding Rules
1. **Two-way** (`r(getter, setter)`): member expressions (`state.name`, `props.count`) and mutable bare identifiers (`let`/`var`).
2. **One-way** (`r(() => expr)`): complex expressions (calls, template literals, binary ops with non-safe operands).
3. **No wrapping**: `const` variables, imports, function declarations, parameters, literals, arrow functions, safe objects/arrays — `isSafeExpression` returns `true`.
4. The check uses Babel's `path.scope.getBinding(name).kind` to distinguish `let`/`var` from `const`/`module`/`param`/`hoisted`.

## Reconciler Gotchas
1. **Don't double-wrap in `processChildren`**: `renderChild` must return `renderer.render(scope)` array results directly — NOT wrapped in another `processChildren()`. `render()` already returns a `processChildren` result for components/fragments. Double-wrapping stores a reactive array inside a reactive array. When the inner one is replaced, mutts' `recursiveTouching` (same prototype → recursive diff path) swallows the identity-change notification, so the outer `flattenNodes` lift is never notified and `reconcile` never updates the DOM.