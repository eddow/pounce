**This plugin is tagged for deletion. It exists for the sole purpose of reference and should not be further used/corrected/modified.**

# Pounce-UI Documentation

## Overview
Pounce-UI provides the standard component library for Pounce applications. It is built on `@pounce/core` and uses `mutts` for state.

## Styling
*   **PicoCSS**: Used as the base CSS framework.
*   **Sass**: Custom styles are written in SCSS.
*   **SSR Support**: Exports `getSSRStyles` for server-side style injection with hydration support.

## Components
*   **Dockview**: Integrates `dockview-core` for window management.
*   **Standard Controls**: Inputs, Buttons, etc., designed to work with Pounce's two-way binding system.
*   **Multiselect**: A dropdown component for selecting multiple items from a list, with customizable trigger and item rendering.

## Utilities
### `stored(initialState)`
Located in `src/lib/storage.ts`.
Creates a reactive state that is automatically synchronized with `localStorage`.
- **SSR-proof**: Safely handles non-browser environments.
- **Inter-tab sync**: Listens to `storage` events to sync across tabs.
- **JSON Serialization**: Values are stored as JSON strings.
- **Playwright-proof**: Robust against restricted storage access.

```tsx
import { stored } from '../lib/storage'
const state = stored({ theme: 'light' })
// updates to state.theme persist to localStorage
// updates from other tabs automatically update state.theme
```

### `<dynamic>` Tag Stability
- **Stable for interactive components**: The `<dynamic>` tag in `@pounce/core` is now stable. It only recreation the DOM node when the `tag` property changes. Other property updates are handled reactively by the element itself, preserving state (like focus and scroll).
- **Proper usage**: Use `<dynamic tag={state.tag} ... />` to ensure reactivity if the `tag` can change.

## Actions (Directives)

Actions are functions that allow you to attach behavior to DOM elements using the `use:action` syntax.

### 1. Usage Syntax
```tsx
<div use:myAction={value} />
```
- `myAction`: The function to run.
- `value`: The argument passed to the function.

### 2. CRITICAL: Scope Injection
Unlike components which are imported, **actions must be available in the template's scope**.
Before you can use `use:resize`, you must inject the `resize` function into the scope.

**Global Injection (preferred):**
```tsx
import { bindApp } from '@pounce/core'
import * as actions from '@pounce/pico/src/actions'
bindApp(<App />, '#app', actions)
```

**Alternative (Local/Manual):**
```tsx
import { resize, scroll } from '@pounce/pico'

const App = (props, scope) => {
    scope.resize = resize
    scope.scroll = scroll
    // ...
}
```

### 3. Available Actions

#### `pointer`
Support for tracking pointer position and button state (read-only).

```tsx
const state = reactive({ value: undefined });
// Updates provided variable with { x, y, buttons } or undefined when leaving
<div use:pointer={{ value: state }}>...</div>
```

#### `resize`
Support for `ResizeObserver` with two-way binding.

```tsx
const size = reactive({ width: 0, height: 0 })
// Bi-directional: updating size changes style, resizing element updates size
<div use:resize={size} style="resize: both; overflow: auto;"></div>
```

#### `scroll`
Support for scroll position binding.

```tsx
const scrollState = reactive({ value: 0, max: 0 })
// Bi-directional X-axis scroll
<div use:scroll={{ x: scrollState }}>...</div>
```

#### `intersect`
Support for `IntersectionObserver`.

```tsx
const onEnter = () => ...
<div use:intersect={{ onEnter, threshold: 0.5 }}>...</div>
```

### 4. Writing Custom Actions

#### Best Practice: Bi-Directional Binding (`biDi`)
When writing actions that sync DOM state (like input values or scroll position) with reactive state, **always use `biDi`** to prevent infinite loops.

```typescript
import { biDi } from 'mutts'

export function myAction(el, model, scope) {
    const provide = biDi(
        (val) => el.value = val,    // External setter (Reactive -> DOM)
        () => model.value,          // Reactive getter
        (val) => model.value = val  // Reactive setter
    )
    
    // DOM -> Reactive
    el.addEventListener('input', () => provide(el.value))
}
```

#### Best Practice: Input Isolation
If an action controls an input's value, ensure the input is not re-generated by parent renders (e.g. avoid mixing dynamic text nodes directly as siblings of the input in a shared parent if that parent re-renders frequently). Isolate the input or the text in their own containers.

### 5. JSX Conditional Rendering
> [!IMPORTANT]
> **Avoid `? :` and `&&` for Conditionals**
> *   **Bad**: `{condition ? <A/> : <B/>}` or `{condition && <A/>}`. These cause full re-renders of the expression.
> *   **Good**: Use `if` / `else` attributes on elements, or `<fragment if={...}>`.
> *   Example: `<div if={condition}>...</div>` or `<fragment if={condition}><A/></fragment><B else/>`.
